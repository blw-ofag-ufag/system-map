<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device--width, initial-scale=1.0">
    <title>Linked Data Viewer</title>
    <script src="https://unpkg.com/n3/browser/n3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Source+Code+Pro:wght@400;500&display=swap');

        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --background-color: #f8f9fa;
            --table-bg-color: #ffffff;
            --table-border-color: #dee2e6;
            --text-color: #343a40;
            --link-color: #2980b9;
            --footnote-color: #e74c3c;
            --tag-bg-color: #ecf0f1;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            margin: 0;
            padding: 2rem;
            display: flex;
            justify-content: center;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background-color: var(--table-bg-color);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        header {
            background-color: var(--secondary-color);
            color: white;
            padding: 2rem;
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 2rem;
            font-weight: 700;
        }

        header p {
            margin: 0.5rem 0 0;
            font-family: 'Source Code Pro', monospace;
            font-size: 1rem;
            opacity: 0.8;
            word-break: break-all;
        }

        main {
            padding: 2rem;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--primary-color);
            animation: spin 1s ease infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 2rem;
        }

        th, td {
            padding: 1rem 1.25rem;
            text-align: left;
            border-bottom: 1px solid var(--table-border-color);
            vertical-align: top;
        }

        th {
            background-color: var(--background-color);
            font-weight: 500;
            color: var(--secondary-color);
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 0.05em;
        }

        td.predicate {
            font-family: 'Source Code Pro', monospace;
            font-weight: 500;
            width: 35%;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        a:hover {
            color: var(--primary-color);
            text-decoration: underline;
        }
        
        .footnote-ref {
            display: inline-block;
            background-color: var(--footnote-color);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 8px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .footnote-ref:hover {
            transform: scale(1.1);
        }

        .footnotes {
            padding-top: 1rem;
            border-top: 2px solid var(--table-border-color);
        }

        .footnotes h2 {
            margin-top: 0;
            color: var(--secondary-color);
        }

        .footnotes ol {
            padding-left: 1.5rem;
        }

        .footnotes li {
            margin-bottom: 0.75rem;
        }

        .lang-tag {
            font-size: 0.8em;
            padding: 0.2em 0.5em;
            background-color: var(--tag-bg-color);
            border-radius: 4px;
            margin-left: 0.5em;
            font-family: 'Source Code Pro', monospace;
        }

        .lang-tag-en {
            font-weight: bold;
        }

        .lang-tag-other {
            opacity: 0.7;
        }

    </style>
</head>
<body>

    <div class="container">
        <header id="header">
            </header>
        <main>
            <div id="loader" class="spinner"></div>
            <table id="spo-table" style="display: none;">
                <thead>
                    <tr>
                        <th>Predicate</th>
                        <th>Object</th>
                    </tr>
                </thead>
                <tbody>
                    </tbody>
            </table>
            <div id="footnotes" class="footnotes" style="display: none;">
                <h2>Footnotes</h2>
                <ol id="footnotes-list">
                    </ol>
            </div>
        </main>
    </div>

    <script>
        const { DataFactory, Parser } = N3;
        const { namedNode, literal, defaultGraph, quad } = DataFactory;

        const RDF_TYPE = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type';
        const RDFS_LABEL = 'http://www.w3.org/2000/01/rdf-schema#label';
        const SCHEMA_NAME = 'http://schema.org/name';
        const DCTERMS_TITLE = 'http://purl.org/dc/terms/title';
        const SKOS_PREFLABEL = 'http://www.w3.org/2004/02/skos/core#prefLabel';

        const LABEL_PREDICATES = [RDFS_LABEL, SCHEMA_NAME, DCTERMS_TITLE, SKOS_PREFLABEL];

        // Cache for fetched labels to avoid re-fetching
        const labelCache = new Map();

        /**
         * Fetches and parses RDF data from a URL
         */
        async function fetchRdf(url) {
            try {
                const response = await fetch(url, { headers: { 'Accept': 'text/turtle' } });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                const parser = new Parser();
                const store = new N3.Store();
                return new Promise((resolve, reject) => {
                    parser.parse(text, (error, quad, prefixes) => {
                        if (error) reject(error);
                        if (quad) store.addQuad(quad);
                        else resolve(store);
                    });
                });
            } catch (error) {
                console.error(`Error fetching or parsing ${url}:`, error);
                return null;
            }
        }

        /**
         * Fetches a human-readable label for a given URI
         */
        async function getLabel(uri) {
            if (labelCache.has(uri)) {
                return labelCache.get(uri);
            }
            
            const store = await fetchRdf(uri);
            if (!store) {
                 labelCache.set(uri, null);
                 return null;
            }

            for (const p of LABEL_PREDICATES) {
                const labels = store.getQuads(namedNode(uri), namedNode(p), null, defaultGraph());
                if (labels.length > 0) {
                    // Prioritize English labels
                    const enLabel = labels.find(q => q.object.language === 'en');
                    const bestLabel = enLabel ? enLabel.object.value : labels[0].object.value;
                    labelCache.set(uri, bestLabel);
                    return bestLabel;
                }
            }
            
            labelCache.set(uri, null);
            return null;
        }
        
        /**
         * Renders a term (subject, predicate, or object) into an HTML string
         */
        async function renderTerm(term) {
            if (term.termType === 'NamedNode') {
                const label = await getLabel(term.value);
                return `<a href="${term.value}" target="_blank">${label || term.value}</a>`;
            }
            if (term.termType === 'Literal') {
                 if (term.language) {
                    const langClass = term.language.startsWith('en') ? 'lang-tag-en' : 'lang-tag-other';
                    return `"${term.value}" <span class="${langClass}"><span class="lang-tag">${term.language}</span></span>`;
                }
                if (term.datatype) {
                    return `"${term.value}"^^<a href="${term.datatype.value}" target="_blank">${term.datatype.value.split('#').pop()}</a>`;
                }
                return `"${term.value}"`;
            }
            return term.value;
        }

        /**
         * Finds and processes reification statements
         */
        function processReifications(store) {
            const reifications = new Map();
            const reifiedQuads = store.getQuads(null, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement'), defaultGraph());
            
            reifiedQuads.forEach(reifiedQuad => {
                const statementId = reifiedQuad.subject;
                const subject = store.getQuads(statementId, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#subject'), null, defaultGraph())[0]?.object;
                const predicate = store.getQuads(statementId, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate'), null, defaultGraph())[0]?.object;
                const object = store.getQuads(statementId, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#object'), null, defaultGraph())[0]?.object;

                if (subject && predicate && object) {
                    const key = `${subject.value}-${predicate.value}-${object.value}`;
                    const annotations = store.getQuads(statementId, null, null, defaultGraph()).filter(q => q.predicate.value !== RDF_TYPE && !q.predicate.value.startsWith('http://www.w3.org/1999/02/22-rdf-syntax-ns#'));
                    reifications.set(key, annotations);
                }
            });
            return reifications;
        }


        /**
         * Main function to drive the application
         */
        async function main() {
            const initialUrl = 'https://agriculture.ld.admin.ch/plant-protection/W-7300?format=ttl';
            const store = await fetchRdf(initialUrl);

            if (!store) {
                 document.getElementById('loader').textContent = 'Failed to load data.';
                return;
            }

            const mainSubjectUri = initialUrl.split('?')[0];
            const mainSubject = namedNode(mainSubjectUri);
            
            // Set header
            const mainLabel = await getLabel(mainSubjectUri) || mainSubjectUri;
            document.getElementById('header').innerHTML = `<h1>${mainLabel}</h1><p>${mainSubjectUri}</p>`;
            
            const reifications = processReifications(store);
            let footnoteCounter = 0;
            const footnotesList = document.getElementById('footnotes-list');

            // Group quads by predicate
            const predicatesMap = new Map();
            store.getQuads(mainSubject, null, null, defaultGraph())
                 .filter(q => q.predicate.value !== RDF_TYPE) // Exclude rdf:type from main table, it's often used as a title
                 .forEach(q => {
                    if (!predicatesMap.has(q.predicate.value)) {
                        predicatesMap.set(q.predicate.value, []);
                    }
                    predicatesMap.get(q.predicate.value).push(q);
                 });


            const tbody = document.querySelector('#spo-table tbody');
            for (const [predicateUri, quads] of predicatesMap.entries()) {
                const predicateTerm = quads[0].predicate;

                for (let i = 0; i < quads.length; i++) {
                    const row = tbody.insertRow();
                    const quad = quads[i];

                    // Predicate cell (with rowspan)
                    if (i === 0) {
                        const predicateCell = row.insertCell();
                        predicateCell.classList.add('predicate');
                        predicateCell.rowSpan = quads.length;
                        predicateCell.innerHTML = await renderTerm(predicateTerm);
                    }

                    // Object cell
                    const objectCell = row.insertCell();
                    objectCell.innerHTML = await renderTerm(quad.object);
                    
                    // Check for reifications
                    const reificationKey = `${quad.subject.value}-${quad.predicate.value}-${quad.object.value}`;
                    if (reifications.has(reificationKey)) {
                         footnoteCounter++;
                         const footnoteRef = document.createElement('a');
                         footnoteRef.className = 'footnote-ref';
                         footnoteRef.textContent = footnoteCounter;
                         footnoteRef.href = `#footnote-${footnoteCounter}`;
                         objectCell.appendChild(footnoteRef);

                         const li = document.createElement('li');
                         li.id = `footnote-${footnoteCounter}`;
                         let footnoteHTML = `Annotation for <code>${predicateTerm.value.split('/').pop().split('#').pop()}</code>: <ul>`;
                         
                         const annotations = reifications.get(reificationKey);
                         for(const annotation of annotations) {
                            footnoteHTML += `<li><strong>${await renderTerm(annotation.predicate)}:</strong> ${await renderTerm(annotation.object)}</li>`;
                         }
                         footnoteHTML += '</ul>';
                         li.innerHTML = footnoteHTML;
                         footnotesList.appendChild(li);
                    }
                }
            }

            // Show table and footnotes
            document.getElementById('loader').style.display = 'none';
            document.getElementById('spo-table').style.display = 'table';
            if(footnoteCounter > 0) {
                document.getElementById('footnotes').style.display = 'block';
            }
        }

        // Run the app
        main();

    </script>
</body>
</html>